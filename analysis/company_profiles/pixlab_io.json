{
  "company": "pixlab.io",
  "dominant_topics": [
    0,
    -1
  ],
  "topic_counts": {
    "0": 42,
    "-1": 2
  },
  "topic_descriptions": {
    "0": "access, data, security, time, information"
  },
  "framing_scores": {
    "framing_ethical": 0.3637992831541218,
    "framing_surveillance": 0.007168458781362,
    "framing_market": 0.6290322580645161,
    "num_docs": 44
  },
  "topic_timeline": {
    "20": {
      "-1": 2,
      "0": 42
    }
  },
  "sample_docs": [
    "Version 2.197 ( Release Notes ↗ ) SyNumpy ↗ is a lightweight, Open-source C++17 library with comprehensive support for .npy and .npz NumPy files, developed by PixLab . It enables seamless integration of Python's data structures into C++ applications, facilitating efficient reading, writing, and manipulation of multidimensional arrays. Designed for flexibility, SyNumpy ↗ ensures high performance and easy compatibility across platforms. Features Getting Started C++17 API Reference Guide Features SyNumpy ↗ provides robust tools for handling .npy and .npz files, including array loading and saving, append mode for extending data dimensions, and precise endian checks for system compatibility. Its core component, NpyArray , stores array shapes, data, and metadata efficiently in memory. Optional .npz support enables zip-based archiving for compact storage, ensuring flexibility and ease of use across various projects. NpyArray: A container that stores the loaded array's shape, word size, fortran order, and data in memory. Load & Save: syNumpy::loadNpy(...) reads from a file. syNumpy::loadNpyBuffer(...) reads from a raw memory buffer. syNumpy::saveNpy(...) writes or appends data. Append Mode: Save with mode = \"a\" to extend the first dimension of an existing file (if shapes match). Endian Checks: Warn if the file is big-endian while the system is little-endian (or vice versa). No auto-swapping. Optional NPZ: -DSYNUMPY_ENABLE_NPZ=1 enables zip-based .npz archiving (requires zlib). Minimal example included. Getting Started To use syNumpy in your C++17 project, start by including the syNumpy.hpp header file. Ensure that you compile your project with the -std=c++17 flag. Additionally, for .np z archiving, you can optionally define SYNUMPY Include syNumpy.hpp in your C++17 project. Compile with -std=c++17 . Optional: Define SYNUMPY_ENABLE_NPZ=1 for .npz archiving. Minimal Example #include \"syNumpy.hpp\" #include <iostream> int main () { // 1) Save a float array { std::vector< float > data = { 1.0f , 2.0f , 3.0f }; syNumpy::saveNpy( \"floats.npy\" , data); // overwrites if file exists } // 2) Load it back { syNumpy::NpyArray arr = syNumpy::loadNpy( \"floats.npy\" ); std::vector< float > loaded = arr.asVector< float >(); std::cout << \"Loaded \" << loaded.size() << \" floats: \" ; for ( auto f : loaded) std::cout << f << \" \" ; std::cout << \"\\n\" ; } #if SYNUMPY_ENABLE_NPZ // 3 Create a .npz archive with multiple arrays { syNumpy::NpzArchive zip; std::vector< int > arr1 = { 10 , 20 , 30 }; std::vector< double > arr2 = { 3.14 , 2.71 }; zip.addArray( \"ints\" , arr1); zip.addArray( \"doubles\" , arr2); zip.save( \"arrays.npz\" ); } #endif return 0 ; } C++17 API REFERENCE GUIDE This is the C++ interface for SyNumpy. Documentation is being updated until the libraries reach a stable release. Developers integrating SyNumpy into their C++ codebase should periodically check this page for updated documentation of the exported C++ API once stable. Version 2.197 ( Release Notes ↗ ) SyNumpy ↗ is a lightweight, Open-source C++17 library with comprehensive support for .npy and .npz NumPy files, developed by PixLab . It enables seamless integration of Python's data structures into C++ applications, facilitating efficient reading, writing, and manipulation of multidimensional arrays. Designed for flexibility, SyNumpy ↗ ensures high performance and easy compatibility across platforms. Features Getting Started C++17 API Reference Guide Features SyNumpy ↗ provides robust tools for handling .npy and .npz files, including array loading and saving, append mode for extending data dimensions, and precise endian checks for system compatibility. Its core component, NpyArray , stores array shapes, data, and metadata efficiently in memory. Optional .npz support enables zip-based archiving for compact storage, ensuring flexibility and ease of use across various projects. NpyArray: A container that stores the loaded array's shape, word size, fortran order, and data in memory. Load & Save: syNumpy::loadNpy(...) reads from a file. syNumpy::loadNpyBuffer(...) reads from a raw memory buffer. syNumpy::saveNpy(...) writes or appends data. Append Mode: Save with mode = \"a\" to extend the first dimension of an existing file (if shapes match). Endian Checks: Warn if the file is big-endian while the system is little-endian (or vice versa). No auto-swapping. Optional NPZ: -DSYNUMPY_ENABLE_NPZ=1 enables zip-based .npz archiving (requires zlib). Minimal example included. Getting Started To use syNumpy in your C++17 project, start by including the syNumpy.hpp header file. Ensure that you compile your project with the -std=c++17 flag. Additionally, for .np z archiving, you can optionally define SYNUMPY Include syNumpy.hpp in your C++17 project. Compile with -std=c++17 . Optional: Define SYNUMPY_ENABLE_NPZ=1 for .npz archiving. Minimal Example #include \"syNumpy.hpp\" #include <iostream> int main () { // 1) Save a float array { std::vector< float > data = { 1.0f , 2.0f , 3.0f }; syNumpy::saveNpy( \"floats.npy\" , data); // overwrites if file exists } // 2) Load it back { syNumpy::NpyArray arr = syNumpy::loadNpy( \"floats.npy\" ); std::vector< float > loaded = arr.asVector< float >(); std::cout << \"Loaded \" << loaded.size() << \" floats: \" ; for ( auto f : loaded) std::cout << f << \" \" ; std::cout << \"\\n\" ; } #if SYNUMPY_ENABLE_NPZ // 3 Create a .npz archive with multiple arrays { syNumpy::NpzArchive zip; std::vector< int > arr1 = { 10 , 20 , 30 }; std::vector< double > arr2 = { 3.14 , 2.71 }; zip.addArray( \"ints\" , arr1); zip.addArray( \"doubles\" , arr2); zip.save( \"arrays.npz\" ); } #endif return 0 ; } C++17 API REFERENCE GUIDE This is the C++ interface for SyNumpy. Documentation is being updated until the libraries reach a stable release. Developers integrating SyNumpy into their C++ codebase should periodically check this page for updated documentation of the exported C++ API once stable. Version 2.197 ( Release Notes ↗ ) SyNumpy ↗ is a lightweight, Open-source C++17 library with comprehensive support for .npy and .npz NumPy files, developed by PixLab . It enables seamless integration of Python's data structures into C++ applications, facilitating efficient reading, writing, and manipulation of multidimensional arrays. Designed for flexibility, SyNumpy ↗ ensures high performance and easy compatibility across platforms. C++17 API Reference Guide SyNumpy ↗ provides robust tools for handling .npy and .npz files, including array loading and saving, append mode for extending data dimensions, and precise endian checks for system compatibility. Its core component, NpyArray , stores array shapes, data, and metadata efficiently in memory. Optional .npz support enables zip-based archiving for compact storage, ensuring flexibility and ease of use across various projects. NpyArray: A container that stores the loaded array's shape, word size, fortran order, and data in memory. NpyArray: A container that stores the loaded array's shape, word size, fortran order, and data in memory. Load & Save: syNumpy::loadNpy(...) reads from a file. syNumpy::loadNpyBuffer(...) reads from a raw memory buffer. syNumpy::saveNpy(...) writes or appends data. syNumpy::loadNpy(...) reads from a file. syNumpy::loadNpyBuffer(...) reads from a raw memory buffer. syNumpy::saveNpy(...) writes or appends data. Append Mode: Save with mode = \"a\" to extend the first dimension of an existing file (if shapes match). Append Mode: Save with mode = \"a\" to extend the first dimension of an existing file (if shapes match). Endian Checks: Warn if the file is big-endian while the system is little-endian (or vice versa). No auto-swapping. Endian Checks: Warn if the file is big-endian while the system is little-endian (or vice versa). No auto-swapping. Optional NPZ: -DSYNUMPY_ENABLE_NPZ=1 enables zip-based .npz archiving (requires zlib). Minimal example included. Optional NPZ: -DSYNUMPY_ENABLE_NPZ=1 enables zip-based .npz archiving (requires zlib). Minimal example included. To use syNumpy in your C++17 project, start by including the syNumpy.hpp header file. Ensure that you compile your project with the -std=c++17 flag. Additionally, for .np z archiving, you can optionally define SYNUMPY Include syNumpy.hpp in your C++17 project. Compile with -std=c++17 . Optional: Define SYNUMPY_ENABLE_NPZ=1 for .npz archiving. C++17 API REFERENCE GUIDE This is the C++ interface for SyNumpy. Documentation is being updated until the libraries reach a stable release. Developers integrating SyNumpy into their C++ codebase should periodically check this page for updated documentation of the exported C++ API once stable.",
    "Version 1.9.72 ( Release Notes ) If your organization requires more control or has strict compliance requirements, PixLab on-premises is right for you. PixLab on-premises allows organizations with restrictive IT policies or requirements for tighter integration to deploy portion or the entire PixLab stack on their own infrastructure, giving them complete control over their media assets. The on-premise version of PixLab contains exactly the same features as the cloud solution , and it will require minimal IT intervention to deploy and maintain. Please note that PixLab on-premises is reserved for established business organizations such as enterprise class customers. For individuals, small or medium businesses & startups, you should rely on the cloud plans as they are the most affordable, efficient, and privacy friendly where you can connect your AWS S3 buckets for complete control over your media assets . Features Complete control over your processed media assets. No assets leaves the deployment server. Passports & ID Cards scanner similar to the cloud DOCSCAN API endpoint . Optional Facial Recognition engine powered by FACEIO . Not Safe for Work ( NSFW ) content detection similar to the cloud NSFW API endpoint . Image/Video tagging, content extraction & description similar to the cloud TAGIMG API endpoint . Image & Video Analysis TLS Encrypted Transactions Straightforward & Automated Installation Continuous Updates, Bugs & Security Fixes Priority Email Support Completely Disabled Telemetry System Requirements The following table summarize the minimal & technical requirements needed to deploy PixLab on-premises on your own infrastructure: Technical Requirements CPU 4 cores at least with AVX, SSEx instructions set . Modern cloud Virtual Machines (VM), and bare metal machines are fully supported . The more cores you can afford, the more concurrent analysis you can process at instant T. GPU NVDIA CUDA and cuDNN . Not required, but highly recommended . RAM ≥ 32 GB DDR4 Operating System 64-bit Linux (Debian|Ubuntu|RHEL) or FreeBSD . Disk Space ≥ 256 GB SSD or NVME Software Stack Python 3.7 or higher, OpenSSL, Modern Clang or GCC compiler suite. Package Order & Delivery PixLab on-premises can be ordered at anytime via the checkout button below . Once your order is received, you'll shortly receive a package composed of the following: Precompiled & Binary Packages for Deployment Download Tokens for Updates Automated (wizard) Installation Script Deployment Documentation Commercial License Agreement Dashboard Access Credentials for Support Tickets 90 Days of Integration Support & Assistance Order PixLab On-Premises Now Version 1.9.72 ( Release Notes ) If your organization requires more control or has strict compliance requirements, PixLab on-premises is right for you. PixLab on-premises allows organizations with restrictive IT policies or requirements for tighter integration to deploy portion or the entire PixLab stack on their own infrastructure, giving them complete control over their media assets. The on-premise version of PixLab contains exactly the same features as the cloud solution , and it will require minimal IT intervention to deploy and maintain. Please note that PixLab on-premises is reserved for established business organizations such as enterprise class customers. For individuals, small or medium businesses & startups, you should rely on the cloud plans as they are the most affordable, efficient, and privacy friendly where you can connect your AWS S3 buckets for complete control over your media assets . Complete control over your processed media assets. No assets leaves the deployment server. Passports & ID Cards scanner similar to the cloud DOCSCAN API endpoint . Optional Facial Recognition engine powered by FACEIO . Not Safe for Work ( NSFW ) content detection similar to the cloud NSFW API endpoint . Image/Video tagging, content extraction & description similar to the cloud TAGIMG API endpoint . Image & Video Analysis Straightforward & Automated Installation Continuous Updates, Bugs & Security Fixes The following table summarize the minimal & technical requirements needed to deploy PixLab on-premises on your own infrastructure: Package Order & Delivery PixLab on-premises can be ordered at anytime via the checkout button below . Once your order is received, you'll shortly receive a package composed of the following: Precompiled & Binary Packages for Deployment Download Tokens for Updates Automated (wizard) Installation Script Dashboard Access Credentials for Support Tickets 90 Days of Integration Support & Assistance",
    "Version 2.197 ( Release Notes ↗ ) In this introductory course, you'll learn how to utilize the PixLab REST API to process and analyze your media assets, including images and video frames, using your favorite programming language. The API Portal , REST API Reference , ID Scan & Extract API , Vision LLM & Playground , and the List of API Endpoints are your go-to references once you understand how PixLab handles incoming HTTP requests. Let's Explore! Features of the PixLab REST API → API Access URL → Authentication & API Keys → Response Success & Error Codes → API Endpoints Categories → Your First API Call ↓ Detect & Extract or Mark Faces ↓ Detect & Blur Human Faces ↓ Programmatically Generate MEMEs ↓ Challenge Bots by Dynamic Image Generation ↓ Scan Passports, ID Cards & KYC Verification Check ↓ Moderate Image Uploads According to their NSFW Score ↓ Your First API Call In order to familiarize yourself with the PixLab API, Let's start with the simplest command: GRAYSCALE . Given an input image, the GRAYSCALE endpoint produce a graylevel image in which the only colors are shades of gray like the following: Input Picture GRAYSCALE (api.pixlab.io/grayscale) Picture Output The output, grayscaled image above was obtained using the following code snippets: Regardless of the underlying programming language, the logic is always same. We made a simple HTTP GET request with the input image URL as a sole parameter. Most API Endpoints support both GET & POST HTTP methods at the same time so you can easily upload your images & videos directly from your mobile or web application for processing. Refer to the Code Samples page on how to do that. Once your request executed, a JSON object with a link field to the image output URL alongside with a status code is returned by default to the caller. Status code 200 indicates success. Any other code indicates failure with an appropriate error message. Refer to the API documentation for the full list of status codes. Sometimes, you would want the raw image content (BLOB) to be returned directly to you instead of the JSON object holding the link to the media asset output. To do that, simply set the blob parameter to true on the incoming HTTP request as follows: https://api.pixlab.io/endpoint? blob=true &param=val . With the blob parameter turned on, the raw asset content is returned directly to the caller rather than being stored on the pixlab.xyz storage cluster. By default, any processed asset is automatically stored on the globally distributed (via Cloudflare ) pixlab.xyz storage cluster so you can access your output assets at request (via the link field of the returned JSON object). If privacy or restrictive storage requirements is an issue, you can connect your own AWS S3 Bucket to serve as the main storage gateway. That way, each time a video or image is processed, it is automatically stored on your own S3 bucket rather than the PixLab public one. This is what most serious customers prefer to do, and this option gives you full control over your processed media assets . Sign-in to your account on the PixLab Console to connect your AWS S3 Bucket. Detect & Extract or Mark Faces Let's tackle a more serious, yet very useful example that mixes analysis & processing API calls at the same time now you understand how the PixLab API Servers handle your incoming HTTP request. First, we will try to detect all human faces present in a given image or video frame via the FACEDETECT endpoint, then, we will extract each detected face in a new image using the CROP endpoint (Useful for your KYC verification form). Input Picture Draw Rectangle instead of CROP Extract (crop) face via CROP This is easily done via the following code snippets: To perform such operation, two endpoints are actually needed: One for the analysis phase, the other for processing: FACEDETECT is the analysis endpoint that must be called first. It outputs the rectangle coordinates for each detected face in a given image or video frame. This endpoint, its expected parameter, and JSON output result is documented here . CROP is called later after we obtain the rectangle coordinates for all the detected faces. In which case, we simply pass these coordinates to crop untouched and the target region of the image where each face is located is extracted and saved in a new image. Find out more information on the CROP endpoint here . Alternatively, if you prefer marking the face(s) instead of extracting it, you can rely on the DRAWRECTANGLE endpoint to perform such operation. Detect & Blur Human Faces Similarly, we could apply a blur filter on all the detected human faces in a given image or video frame using only two PixLab Endpoints. This is very useful in the age of privacy. With privacy regulations changing all the time around the globe and the recent GDPR that came into effect in the EU, it is recommended to comply with all regulations per default by adding/integrating face blurring into your services. A typical output picture after processing should look like the following: Input Picture Output Blurred Faces Again, this is easily achieved using the following snippets: Just like the previous example, we relied on the FACEDETECT endpoint to output the rectangle coordinates for each present human face then, we immediately called the MOGRIFY endpoint, and we simply passed the facial coordinates untouched to mogrify to blur the target regions of the input image hence, the facial coordinates. The mogrify endpoint, its expected parameters, and output results is documented here . Programmatically Generate MEMEs Let's generate a funny MEME by drawing some text on top of the famous Cool Cat , public domain image using the DRAWTEXT API endpoint. Given an input image, draw some text on TOP & BOTTOM of the image to obtain something like this: Input Picture Output Picture, dynamically generated DRAWTEXT The output picture with text drawn on TOP & BOTTOM was obtained via the following code snippets: DRAWTEXT is the sole endpoint needed to generate such image. It expect the text to be displayed on TOP , CENTER or BOTTOM of the target image. This endpoint is so flexible that you can supply Font Name , Size & Color , Stroke width , etc. Refer to DRAWTEXT documentation for additional information. Notice that there is a more flexible endpoint named DRAWTEXTAT which let you draw text on any region of the target image by specifying the X & Y coordinates instead. Challenge Bots by Dynamic Image Generation In this sample, we'll dynamically create a 300x300 pixels, PNG image with a yellow background and draw some text on top. This is very useful, if you want for example to challenge bots on your platform by implementing a minimalistic yet powerful Captcha-like challenge. A typical generated image should look like the following using the steps below: Dynamically created using NEWIMAGE , text drawn via DRAWTEXT A blank image is requested first via a call NEWIMAGE which export to PNG by default but you can change the output format at request. We set the image height , width and the background color respectively to 300x300 with a yellow background color. Note, if one of the height or width parameter is missing (but not both), then the available length is applied to the missing side and if you want a transparent image set the color parameter to none . We finally DRAW our text at the center of the newly created image using the WOLF Font , black color and 35 px font size . One could also draw lines , a rectangle , and other shapes for example to surround faces , merge with other images and so on... After generating such image, the automated script, hence the bot scrapping your platform, has to resolve your challenge by typing the text drawn on top of this image . The whole image creation process is done via the following code snippets: Scan Passports, ID Cards & KYC Verification Check In this sample, you will learn how to make use of the DOCSCAN endpoint to implement a minimalistic KYC (Know Your Customer) form for your web site, and verify the authenticity of the personal information submitted by any of your users using an image upload of their ID card or Passport. We'll start by scanning a government issued, travel document such as Passport, Visa or ID card from various countries using the DOCSCAN API endpoint. Besides its highly accurate text scanning capability, DOCSCAN should also extract (i.e. crop) any detected face within the target document. A typical input passport specimen and the scanned output fields should look like the following after processing: Input Passport Specimen Extracted MRZ Fields The extracted face, plus the scanned Passport MRZ fields were obtained via the following code snippets: DOCSCAN is the sole endpoint needed for such a task. It support various ID cards besides Passports & Visas and does face extraction automatically for you. PixLab recommend that you connect your AWS S3 bucket via the dashboard ↗ so that, any extracted face or MRZ crop is automatically stored on your S3 bucket rather than the PixLab one . This feature should give you full control over your analyzed media files. Refer to the docscan documentation for additional information such as the set of scanned fields, where face crops are stored, how to process PDF documents instead of images and so forth. Moderate Image Uploads According to their NSFW Score In this last sample, we shall censor image uploads according to their NSFW score by applying a blur filter on each image if, and only if, its NSFW score is high enough. A typical blurred picture should look like the following after processing: To filter, and obtain such blurred image, we used the following code snippets: To perform such operation, two endpoints are actually needed. One for the analysis phase, the other for processing: NSFW is the analysis endpoint that must be called first. It does perform nudity & adult content detection and returns a score value between 0..1. The more this value approaches 1, the more your picture/frame is highly nsfw . Find out more information about NSFW here . BLUR is called later only if the nsfw score value returned earlier is greater than certain threshold . In our case, it is set to 0.5. The blur endpoint is documented here . Further Reading Congratulation ðŸ'. If you have followed this tutorial since the beginning, you should already have a good understanding on PixLab handle your incoming HTTP request. As you may notice, all the examples shown above are fully operational, easy to read and self-explanatory. The reader is now encouraged to dig further into the PixLab API by following the links below. Don't forget to refer to the Github sample repository for more samples. Api reference guide Code Samples Api Endpoints Ask questions Version 2.197 ( Release Notes ↗ ) In this introductory course, you'll learn how to utilize the PixLab REST API to process and analyze your media assets, including images and video frames, using your favorite programming language. The API Portal , REST API Reference , ID Scan & Extract API , Vision LLM & Playground , and the List of API Endpoints are your go-to references once you understand how PixLab handles incoming HTTP requests. Let's Explore! Features of the PixLab REST API → API Access URL → Authentication & API Keys → Response Success & Error Codes → API Endpoints Categories → Your First API Call ↓ Detect & Extract or Mark Faces ↓ Detect & Blur Human Faces ↓ Programmatically Generate MEMEs ↓ Challenge Bots by Dynamic Image Generation ↓ Scan Passports, ID Cards & KYC Verification Check ↓ Moderate Image Uploads According to their NSFW Score ↓ Your First API Call In order to familiarize yourself with the PixLab API, Let's start with the simplest command: GRAYSCALE . Given an input image, the GRAYSCALE endpoint produce a graylevel image in which the only colors are shades of gray like the following: Input Picture GRAYSCALE (api.pixlab.io/grayscale) Picture Output The output, grayscaled image above was obtained using the following code snippets: Regardless of the underlying programming language, the logic is always same. We made a simple HTTP GET request with the input image URL as a sole parameter. Most API Endpoints support both GET & POST HTTP methods at the same time so you can easily upload your images & videos directly from your mobile or web application for processing. Refer to the Code Samples page on how to do that. Once your request executed, a JSON object with a link field to the image output URL alongside with a status code is returned by default to the caller. Status code 200 indicates success. Any other code indicates failure with an appropriate error message. Refer to the API documentation for the full list of status codes. Sometimes, you would want the raw image content (BLOB) to be returned directly to you instead of the JSON object holding the link to the media asset output. To do that, simply set the blob parameter to true on the incoming HTTP request as follows: https://api.pixlab.io/endpoint? blob=true &param=val . With the blob parameter turned on, the raw asset content is returned directly to the caller rather than being stored on the pixlab.xyz storage cluster. By default, any processed asset is automatically stored on the globally distributed (via Cloudflare ) pixlab.xyz storage cluster so you can access your output assets at request (via the link field of the returned JSON object). If privacy or restrictive storage requirements is an issue, you can connect your own AWS S3 Bucket to serve as the main storage gateway. That way, each time a video or image is processed, it is automatically stored on your own S3 bucket rather than the PixLab public one. This is what most serious customers prefer to do, and this option gives you full control over your processed media assets . Sign-in to your account on the PixLab Console to connect your AWS S3 Bucket. Detect & Extract or Mark Faces Let's tackle a more serious, yet very useful example that mixes analysis & processing API calls at the same time now you understand how the PixLab API Servers handle your incoming HTTP request. First, we will try to detect all human faces present in a given image or video frame via the FACEDETECT endpoint, then, we will extract each detected face in a new image using the CROP endpoint (Useful for your KYC verification form). Input Picture Draw Rectangle instead of CROP Extract (crop) face via CROP This is easily done via the following code snippets: To perform such operation, two endpoints are actually needed: One for the analysis phase, the other for processing: FACEDETECT is the analysis endpoint that must be called first. It outputs the rectangle coordinates for each detected face in a given image or video frame. This endpoint, its expected parameter, and JSON output result is documented here . CROP is called later after we obtain the rectangle coordinates for all the detected faces. In which case, we simply pass these coordinates to crop untouched and the target region of the image where each face is located is extracted and saved in a new image. Find out more information on the CROP endpoint here . Alternatively, if you prefer marking the face(s) instead of extracting it, you can rely on the DRAWRECTANGLE endpoint to perform such operation. Detect & Blur Human Faces Similarly, we could apply a blur filter on all the detected human faces in a given image or video frame using only two PixLab Endpoints. This is very useful in the age of privacy. With privacy regulations changing all the time around the globe and the recent GDPR that came into effect in the EU, it is recommended to comply with all regulations per default by adding/integrating face blurring into your services. A typical output picture after processing should look like the following: Input Picture Output Blurred Faces Again, this is easily achieved using the following snippets: Just like the previous example, we relied on the FACEDETECT endpoint to output the rectangle coordinates for each present human face then, we immediately called the MOGRIFY endpoint, and we simply passed the facial coordinates untouched to mogrify to blur the target regions of the input image hence, the facial coordinates. The mogrify endpoint, its expected parameters, and output results is documented here . Programmatically Generate MEMEs Let's generate a funny MEME by drawing some text on top of the famous Cool Cat , public domain image using the DRAWTEXT API endpoint. Given an input image, draw some text on TOP & BOTTOM of the image to obtain something like this: Input Picture Output Picture, dynamically generated DRAWTEXT The output picture with text drawn on TOP & BOTTOM was obtained via the following code snippets: DRAWTEXT is the sole endpoint needed to generate such image. It expect the text to be displayed on TOP , CENTER or BOTTOM of the target image. This endpoint is so flexible that you can supply Font Name , Size & Color , Stroke width , etc. Refer to DRAWTEXT documentation for additional information. Notice that there is a more flexible endpoint named DRAWTEXTAT which let you draw text on any region of the target image by specifying the X & Y coordinates instead. Challenge Bots by Dynamic Image Generation In this sample, we'll dynamically create a 300x300 pixels, PNG image with a yellow background and draw some text on top. This is very useful, if you want for example to challenge bots on your platform by implementing a minimalistic yet powerful Captcha-like challenge. A typical generated image should look like the following using the steps below: Dynamically created using NEWIMAGE , text drawn via DRAWTEXT A blank image is requested first via a call NEWIMAGE which export to PNG by default but you can change the output format at request. We set the image height , width and the background color respectively to 300x300 with a yellow background color. Note, if one of the height or width parameter is missing (but not both), then the available length is applied to the missing side and if you want a transparent image set the color parameter to none . We finally DRAW our text at the center of the newly created image using the WOLF Font , black color and 35 px font size . One could also draw lines , a rectangle , and other shapes for example to surround faces , merge with other images and so on... After generating such image, the automated script, hence the bot scrapping your platform, has to resolve your challenge by typing the text drawn on top of this image . The whole image creation process is done via the following code snippets: Scan Passports, ID Cards & KYC Verification Check In this sample, you will learn how to make use of the DOCSCAN endpoint to implement a minimalistic KYC (Know Your Customer) form for your web site, and verify the authenticity of the personal information submitted by any of your users using an image upload of their ID card or Passport. We'll start by scanning a government issued, travel document such as Passport, Visa or ID card from various countries using the DOCSCAN API endpoint. Besides its highly accurate text scanning capability, DOCSCAN should also extract (i.e. crop) any detected face within the target document. A typical input passport specimen and the scanned output fields should look like the following after processing: Input Passport Specimen Extracted MRZ Fields The extracted face, plus the scanned Passport MRZ fields were obtained via the following code snippets: DOCSCAN is the sole endpoint needed for such a task. It support various ID cards besides Passports & Visas and does face extraction automatically for you. PixLab recommend that you connect your AWS S3 bucket via the dashboard ↗ so that, any extracted face or MRZ crop is automatically stored on your S3 bucket rather than the PixLab one . This feature should give you full control over your analyzed media files. Refer to the docscan documentation for additional information such as the set of scanned fields, where face crops are stored, how to process PDF documents instead of images and so forth. Moderate Image Uploads According to their NSFW Score In this last sample, we shall censor image uploads according to their NSFW score by applying a blur filter on each image if, and only if, its NSFW score is high enough. A typical blurred picture should look like the following after processing: To filter, and obtain such blurred image, we used the following code snippets: To perform such operation, two endpoints are actually needed. One for the analysis phase, the other for processing: NSFW is the analysis endpoint that must be called first. It does perform nudity & adult content detection and returns a score value between 0..1. The more this value approaches 1, the more your picture/frame is highly nsfw . Find out more information about NSFW here . BLUR is called later only if the nsfw score value returned earlier is greater than certain threshold . In our case, it is set to 0.5. The blur endpoint is documented here . Further Reading Congratulation ðŸ'. If you have followed this tutorial since the beginning, you should already have a good understanding on PixLab handle your incoming HTTP request. As you may notice, all the examples shown above are fully operational, easy to read and self-explanatory. The reader is now encouraged to dig further into the PixLab API by following the links below. Don't forget to refer to the Github sample repository for more samples. Api reference guide Code Samples Api Endpoints Ask questions Version 2.197 ( Release Notes ↗ ) In this introductory course, you'll learn how to utilize the PixLab REST API to process and analyze your media assets, including images and video frames, using your favorite programming language. The API Portal , REST API Reference , ID Scan & Extract API , Vision LLM & Playground , and the List of API Endpoints are your go-to references once you understand how PixLab handles incoming HTTP requests. Let's Explore! Features of the PixLab REST API → API Access URL → Authentication & API Keys → Response Success & Error Codes → API Endpoints Categories → Your First API Call ↓ Detect & Extract or Mark Faces ↓ Detect & Blur Human Faces ↓ Programmatically Generate MEMEs ↓ Challenge Bots by Dynamic Image Generation ↓ Scan Passports, ID Cards & KYC Verification Check ↓ Moderate Image Uploads According to their NSFW Score ↓ Your First API Call In order to familiarize yourself with the PixLab API, Let's start with the simplest command: GRAYSCALE . Given an input image, the GRAYSCALE endpoint produce a graylevel image in which the only colors are shades of gray like the following: GRAYSCALE (api.pixlab.io/grayscale) Picture Output The output, grayscaled image above was obtained using the following code snippets: Regardless of the underlying programming language, the logic is always same. We made a simple HTTP GET request with the input image URL as a sole parameter. Most API Endpoints support both GET & POST HTTP methods at the same time so you can easily upload your images & videos directly from your mobile or web application for processing. Refer to the Code Samples page on how to do that. Once your request executed, a JSON object with a link field to the image output URL alongside with a status code is returned by default to the caller. Status code 200 indicates success. Any other code indicates failure with an appropriate error message. Refer to the API documentation for the full list of status codes. Sometimes, you would want the raw image content (BLOB) to be returned directly to you instead of the JSON object holding the link to the media asset output. To do that, simply set the blob parameter to true on the incoming HTTP request as follows: https://api.pixlab.io/endpoint? blob=true &param=val . With the blob parameter turned on, the raw asset content is returned directly to the caller rather than being stored on the pixlab.xyz storage cluster. By default, any processed asset is automatically stored on the globally distributed (via Cloudflare ) pixlab.xyz storage cluster so you can access your output assets at request (via the link field of the returned JSON object). If privacy or restrictive storage requirements is an issue, you can connect your own AWS S3 Bucket to serve as the main storage gateway. That way, each time a video or image is processed, it is automatically stored on your own S3 bucket rather than the PixLab public one. This is what most serious customers prefer to do, and this option gives you full control over your processed media assets . Sign-in to your account on the PixLab Console to connect your AWS S3 Bucket. Detect & Extract or Mark Faces Let's tackle a more serious, yet very useful example that mixes analysis & processing API calls at the same time now you understand how the PixLab API Servers handle your incoming HTTP request. First, we will try to detect all human faces present in a given image or video frame via the FACEDETECT endpoint, then, we will extract each detected face in a new image using the CROP endpoint (Useful for your KYC verification form). Draw Rectangle instead of CROP Extract (crop) face via CROP This is easily done via the following code snippets: To perform such operation, two endpoints are actually needed: One for the analysis phase, the other for processing: FACEDETECT is the analysis endpoint that must be called first. It outputs the rectangle coordinates for each detected face in a given image or video frame. This endpoint, its expected parameter, and JSON output result is documented here . CROP is called later after we obtain the rectangle coordinates for all the detected faces. In which case, we simply pass these coordinates to crop untouched and the target region of the image where each face is located is extracted and saved in a new image. Find out more information on the CROP endpoint here . Alternatively, if you prefer marking the face(s) instead of extracting it, you can rely on the DRAWRECTANGLE endpoint to perform such operation. Detect & Blur Human Faces Similarly, we could apply a blur filter on all the detected human faces in a given image or video frame using only two PixLab Endpoints. This is very useful in the age of privacy. With privacy regulations changing all the time around the globe and the recent GDPR that came into effect in the EU, it is recommended to comply with all regulations per default by adding/integrating face blurring into your services. A typical output picture after processing should look like the following: Again, this is easily achieved using the following snippets: Just like the previous example, we relied on the FACEDETECT endpoint to output the rectangle coordinates for each present human face then, we immediately called the MOGRIFY endpoint, and we simply passed the facial coordinates untouched to mogrify to blur the target regions of the input image hence, the facial coordinates. The mogrify endpoint, its expected parameters, and output results is documented here . Let's generate a funny MEME by drawing some text on top of the famous Cool Cat , public domain image using the DRAWTEXT API endpoint. Given an input image, draw some text on TOP & BOTTOM of the image to obtain something like this: Output Picture, dynamically generated DRAWTEXT The output picture with text drawn on TOP & BOTTOM was obtained via the following code snippets: DRAWTEXT is the sole endpoint needed to generate such image. It expect the text to be displayed on TOP , CENTER or BOTTOM of the target image. This endpoint is so flexible that you can supply Font Name , Size & Color , Stroke width , etc. Refer to DRAWTEXT documentation for additional information. Notice that there is a more flexible endpoint named DRAWTEXTAT which let you draw text on any region of the target image by specifying the X & Y coordinates instead. Challenge Bots by Dynamic Image Generation In this sample, we'll dynamically create a 300x300 pixels, PNG image with a yellow background and draw some text on top. This is very useful, if you want for example to challenge bots on your platform by implementing a minimalistic yet powerful Captcha-like challenge. A typical generated image should look like the following using the steps below: Dynamically created using NEWIMAGE , text drawn via DRAWTEXT A blank image is requested first via a call NEWIMAGE which export to PNG by default but you can change the output format at request. We set the image height , width and the background color respectively to 300x300 with a yellow background color. Note, if one of the height or width parameter is missing (but not both), then the available length is applied to the missing side and if you want a transparent image set the color parameter to none . We finally DRAW our text at the center of the newly created image using the WOLF Font , black color and 35 px font size . One could also draw lines , a rectangle , and other shapes for example to surround faces , merge with other images and so on... After generating such image, the automated script, hence the bot scrapping your platform, has to resolve your challenge by typing the text drawn on top of this image . The whole image creation process is done via the following code snippets: Scan Passports, ID Cards & KYC Verification Check In this sample, you will learn how to make use of the DOCSCAN endpoint to implement a minimalistic KYC (Know Your Customer) form for your web site, and verify the authenticity of the personal information submitted by any of your users using an image upload of their ID card or Passport. We'll start by scanning a government issued, travel document such as Passport, Visa or ID card from various countries using the DOCSCAN API endpoint. Besides its highly accurate text scanning capability, DOCSCAN should also extract (i.e. crop) any detected face within the target document. A typical input passport specimen and the scanned output fields should look like the following after processing: The extracted face, plus the scanned Passport MRZ fields were obtained via the following code snippets: DOCSCAN is the sole endpoint needed for such a task. It support various ID cards besides Passports & Visas and does face extraction automatically for you. PixLab recommend that you connect your AWS S3 bucket via the dashboard ↗ so that, any extracted face or MRZ crop is automatically stored on your S3 bucket rather than the PixLab one . This feature should give you full control over your analyzed media files. Refer to the docscan documentation for additional information such as the set of scanned fields, where face crops are stored, how to process PDF documents instead of images and so forth. Moderate Image Uploads According to their NSFW Score In this last sample, we shall censor image uploads according to their NSFW score by applying a blur filter on each image if, and only if, its NSFW score is high enough. A typical blurred picture should look like the following after processing: To filter, and obtain such blurred image, we used the following code snippets: To perform such operation, two endpoints are actually needed. One for the analysis phase, the other for processing: NSFW is the analysis endpoint that must be called first. It does perform nudity & adult content detection and returns a score value between 0..1. The more this value approaches 1, the more your picture/frame is highly nsfw . Find out more information about NSFW here . BLUR is called later only if the nsfw score value returned earlier is greater than certain threshold . In our case, it is set to 0.5. The blur endpoint is documented here . Congratulation ðŸ'. If you have followed this tutorial since the beginning, you should already have a good understanding on PixLab handle your incoming HTTP request. As you may notice, all the examples shown above are fully operational, easy to read and self-explanatory. The reader is now encouraged to dig further into the PixLab API by following the links below. Don't forget to refer to the Github sample repository for more samples.",
    "Media Processing Made Effortless Empower your projects with PixLab's AI-powered tools designed to simplify and accelerate media analysis. From real-time object detection to seamless document processing, our APIs bring unparalleled efficiency and precision to your workflows. Advanced Media Analysis Analyze objects, faces, and content in real-time with AI-driven precision. Intelligent Image Processing Resize, crop, and enhance images or remove backgrounds effortlessly. Video Insights Extract actionable insights from videos with frame-by-frame analysis. Document Analysis & OCR Scan, classify, and extract data from documents with advanced OCR. Bulk Media Processing Toolkit Access over 150 APIs to streamline and scale media processing tasks. Scalable and Developer-Friendly Integrate easily with developer-friendly APIs and scalable infrastructure. Connect to the console GENERATE INSIGHTS FROM MEDIA SEAMLESSLY With PixLab's Media Analysis APIs, analyze videos and images to extract metadata, detect objects, and gain actionable insights. The Media Analysis API simplifies processing complex data into meaningful information—ideal for developers building intelligent applications. BOOST PRODUCTIVITY WITH INTELLIGENT ANALYTICS Automate your media workflows with PixLab's AI-driven analytics. Use our comprehensive REST APIs documentation to seamlessly integrate advanced media analysis capabilities, enhancing efficiency and delivering powerful results for your projects. UNLOCK MEDIA'S FULL POTENTIAL Tap into PixLab's cutting-edge tools to process media efficiently. Whether it's detecting faces, recognizing objects, or generating metadata, you'll have access to a powerful API suite that turns raw media into actionable insights in no time. Get Your API Key Visit the API Portal import requests import json # Convert JPEG image to PNG with transparent background. # https://pixlab.io/endpoints/convert for more info. req = requests.get( 'https://api.pixlab.io/convert' , params={ 'img' : 'https://www.allaboutbirds.org/guide/PHOTO/LARGE/blue_jay_8.jpg' , 'export' : 'png' , 'background' : 'tr' , 'key' : 'Pix_Key' } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Pic Link: \" + reply[ 'link' ]) Add Custom Text to Your Images in Seconds PixLab's API makes it effortless to overlay text on your images. Whether it's a meme, a marketing banner, or just a creative design, you can draw text on the top and bottom of any image. Customize text size, font, color, and more—all with a single API call. Easily overlay text on images using PixLab's API for creative designs like memes or banners. Customize text size, font, and color with a single API call. Draw text at the top or bottom of any image effortlessly. Explore API Portal import requests import json # Draw some funny text on top & bottom of the famous Michael Jordan crying face. req = requests.get( 'https://api.pixlab.io/drawtext' , params={ 'img' : 'https://pixlab.io/images/jdr.jpg' , 'top' : 'someone bumps the table' , 'bottom' : 'right before you win' , 'cap' : True , # Capitalize text 'strokecolor' : 'black' , 'key' : 'Pix_Key' } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Meme: \" + reply[ 'link' ]) Convert PDFs into Stunning Images Transform your PDF documents into high-quality JPEG or PNG images effortlessly with PixLab's API. Perfect for archiving, previews, or sharing, our solution makes conversion quick and seamless—no manual effort required. Transform PDF documents into high-quality JPEG or PNG images with PixLab's API. Ideal for archiving, previews, or sharing without manual effort. Ensure quick and seamless document-to-image conversion. Get your API Key import requests # Convert a PDF document to an image (JPEG/PNG) using PixLab API req = requests.get( 'https://api.pixlab.io/pdftoimg' , params={ 'src' : 'https://www.getharvest.com/downloads/Invoice_Template.pdf' , # PDF source URL 'export' : 'jpeg' , # Output format (jpeg/png) 'key' : 'YOUR_PIXLAB_API_KEY' # Replace with your PixLab API key } ) reply = req.json() if reply[ 'status' ] != 200 : print( \"Error:\" , reply[ 'error' ]) else : print( \"Image URL:\" , reply[ 'link' ]) Simplify Image Format Conversion Effortlessly convert images between formats such as JPEG, PNG, BMP, and TIFF with PixLab's Format Conversion API. Maintain original dimensions or combine with resizing and cropping endpoints for customized output. Simplify media management across platforms with precise and reliable format transformations. Convert images between formats like JPEG, PNG, BMP, and TIFF using PixLab's Format Conversion API. Preserve original dimensions or apply resizing and cropping for tailored output. Simplify media management with precise and reliable format transformations. Explore import requests import json # Convert JPEG image to PNG with transparent background. # https://pixlab.io/endpoints/convert for more info. req = requests.get( 'https://api.pixlab.io/convert' , params={ 'img' : 'https://www.allaboutbirds.org/guide/PHOTO/LARGE/blue_jay_8.jpg' , 'export' : 'png' , 'background' : 'tr' , 'key' : 'Pix_Key' } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Pic Link: \" + reply[ 'link' ]) Intelligent NSFW Detection & Automated Blurring Ensure safe content with PixLab's NSFW Detection API. This endpoint analyzes images or video frames to detect inappropriate content, such as nudity or adult visuals. Based on the NSFW score, the API can automatically apply a blur filter, increasing intensity for higher scores. Automate content moderation and filtering to create a secure and user-friendly platform effortlessly. Use PixLab's NSFW Detection API to analyze images or video frames for inappropriate content like nudity or adult visuals. Automatically apply a blur filter with adjustable intensity based on the NSFW score. Streamline content moderation and filtering to ensure a secure and user-friendly platform. Connect to the console import requests import json # Target Image: Change to any link you want (Possibly adult) or switch to POST if you want to upload your image directly, refer to the REST API code samples for more info. img = 'https://i.redd.it/oetdn9wc13by.jpg' # Your PixLab key key = 'PIXLAB_API_KEY' # Censor an image according to its NSFW score req = requests.get( 'https://api.pixlab.io/nsfw' , params={ 'img' : img, 'key' : key } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) elif reply[ 'score' ] < 0.5 : print( \"No adult content were detected on this picture\" ) else : # Highly NSFW picture print( \"Censoring NSFW picture...\" ) # Call blur with the highest possible radius and sigma req = requests.get( 'https://api.pixlab.io/blur' , params={ 'img' : img, 'key' : key, 'rad' : 50 , 'sig' : 30 } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Censored image: \" + reply[ 'link' ]) Endless Possibilities with PixLab From automating workflows to enhancing user experiences, PixLab APIs power solutions across industries. Discover how our tools can transform your projects and unlock new opportunities. E-commerce Optimization Enhance product images and automate content moderation for online stores. Entertainment & Media Generate metadata, analyze videos, and optimize media libraries effortlessly. Identity Verification Securely verify IDs and process documents with advanced OCR capabilities. Healthcare Solutions Analyze medical images for diagnostics and streamline healthcare workflows. Social Media Platforms Moderate content, detect objects, and enhance user-generated media with AI tools. Business Automation Simplify document processing, data extraction, and media handling for enterprises. Get your API Key Built for scale, trusted by thousands Explore Endless Possibilities with PixLab's APIs API PORTAL CODE SAMPLES INTEGRATION API ENDPOINTS Media Processing Made Effortless Empower your projects with PixLab's AI-powered tools designed to simplify and accelerate media analysis. From real-time object detection to seamless document processing, our APIs bring unparalleled efficiency and precision to your workflows. Advanced Media Analysis Analyze objects, faces, and content in real-time with AI-driven precision. Intelligent Image Processing Resize, crop, and enhance images or remove backgrounds effortlessly. Video Insights Extract actionable insights from videos with frame-by-frame analysis. Document Analysis & OCR Scan, classify, and extract data from documents with advanced OCR. Bulk Media Processing Toolkit Access over 150 APIs to streamline and scale media processing tasks. Scalable and Developer-Friendly Integrate easily with developer-friendly APIs and scalable infrastructure. Connect to the console Media Processing Made Effortless Empower your projects with PixLab's AI-powered tools designed to simplify and accelerate media analysis. From real-time object detection to seamless document processing, our APIs bring unparalleled efficiency and precision to your workflows. Analyze objects, faces, and content in real-time with AI-driven precision. Resize, crop, and enhance images or remove backgrounds effortlessly. Extract actionable insights from videos with frame-by-frame analysis. Document Analysis & OCR Scan, classify, and extract data from documents with advanced OCR. Bulk Media Processing Toolkit Access over 150 APIs to streamline and scale media processing tasks. Integrate easily with developer-friendly APIs and scalable infrastructure. GENERATE INSIGHTS FROM MEDIA SEAMLESSLY With PixLab's Media Analysis APIs, analyze videos and images to extract metadata, detect objects, and gain actionable insights. The Media Analysis API simplifies processing complex data into meaningful information—ideal for developers building intelligent applications. BOOST PRODUCTIVITY WITH INTELLIGENT ANALYTICS Automate your media workflows with PixLab's AI-driven analytics. Use our comprehensive REST APIs documentation to seamlessly integrate advanced media analysis capabilities, enhancing efficiency and delivering powerful results for your projects. UNLOCK MEDIA'S FULL POTENTIAL Tap into PixLab's cutting-edge tools to process media efficiently. Whether it's detecting faces, recognizing objects, or generating metadata, you'll have access to a powerful API suite that turns raw media into actionable insights in no time. Get Your API Key Visit the API Portal import requests import json # Convert JPEG image to PNG with transparent background. # https://pixlab.io/endpoints/convert for more info. req = requests.get( 'https://api.pixlab.io/convert' , params={ 'img' : 'https://www.allaboutbirds.org/guide/PHOTO/LARGE/blue_jay_8.jpg' , 'export' : 'png' , 'background' : 'tr' , 'key' : 'Pix_Key' } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Pic Link: \" + reply[ 'link' ]) Add Custom Text to Your Images in Seconds PixLab's API makes it effortless to overlay text on your images. Whether it's a meme, a marketing banner, or just a creative design, you can draw text on the top and bottom of any image. Customize text size, font, color, and more—all with a single API call. Easily overlay text on images using PixLab's API for creative designs like memes or banners. Customize text size, font, and color with a single API call. Draw text at the top or bottom of any image effortlessly. Explore API Portal import requests import json # Draw some funny text on top & bottom of the famous Michael Jordan crying face. req = requests.get( 'https://api.pixlab.io/drawtext' , params={ 'img' : 'https://pixlab.io/images/jdr.jpg' , 'top' : 'someone bumps the table' , 'bottom' : 'right before you win' , 'cap' : True , # Capitalize text 'strokecolor' : 'black' , 'key' : 'Pix_Key' } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Meme: \" + reply[ 'link' ]) Convert PDFs into Stunning Images Transform your PDF documents into high-quality JPEG or PNG images effortlessly with PixLab's API. Perfect for archiving, previews, or sharing, our solution makes conversion quick and seamless—no manual effort required. Transform PDF documents into high-quality JPEG or PNG images with PixLab's API. Ideal for archiving, previews, or sharing without manual effort. Ensure quick and seamless document-to-image conversion. Get your API Key import requests # Convert a PDF document to an image (JPEG/PNG) using PixLab API req = requests.get( 'https://api.pixlab.io/pdftoimg' , params={ 'src' : 'https://www.getharvest.com/downloads/Invoice_Template.pdf' , # PDF source URL 'export' : 'jpeg' , # Output format (jpeg/png) 'key' : 'YOUR_PIXLAB_API_KEY' # Replace with your PixLab API key } ) reply = req.json() if reply[ 'status' ] != 200 : print( \"Error:\" , reply[ 'error' ]) else : print( \"Image URL:\" , reply[ 'link' ]) Simplify Image Format Conversion Effortlessly convert images between formats such as JPEG, PNG, BMP, and TIFF with PixLab's Format Conversion API. Maintain original dimensions or combine with resizing and cropping endpoints for customized output. Simplify media management across platforms with precise and reliable format transformations. Convert images between formats like JPEG, PNG, BMP, and TIFF using PixLab's Format Conversion API. Preserve original dimensions or apply resizing and cropping for tailored output. Simplify media management with precise and reliable format transformations. Explore import requests import json # Convert JPEG image to PNG with transparent background. # https://pixlab.io/endpoints/convert for more info. req = requests.get( 'https://api.pixlab.io/convert' , params={ 'img' : 'https://www.allaboutbirds.org/guide/PHOTO/LARGE/blue_jay_8.jpg' , 'export' : 'png' , 'background' : 'tr' , 'key' : 'Pix_Key' } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Pic Link: \" + reply[ 'link' ]) Intelligent NSFW Detection & Automated Blurring Ensure safe content with PixLab's NSFW Detection API. This endpoint analyzes images or video frames to detect inappropriate content, such as nudity or adult visuals. Based on the NSFW score, the API can automatically apply a blur filter, increasing intensity for higher scores. Automate content moderation and filtering to create a secure and user-friendly platform effortlessly. Use PixLab's NSFW Detection API to analyze images or video frames for inappropriate content like nudity or adult visuals. Automatically apply a blur filter with adjustable intensity based on the NSFW score. Streamline content moderation and filtering to ensure a secure and user-friendly platform. Connect to the console import requests import json # Target Image: Change to any link you want (Possibly adult) or switch to POST if you want to upload your image directly, refer to the REST API code samples for more info. img = 'https://i.redd.it/oetdn9wc13by.jpg' # Your PixLab key key = 'PIXLAB_API_KEY' # Censor an image according to its NSFW score req = requests.get( 'https://api.pixlab.io/nsfw' , params={ 'img' : img, 'key' : key } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) elif reply[ 'score' ] < 0.5 : print( \"No adult content were detected on this picture\" ) else : # Highly NSFW picture print( \"Censoring NSFW picture...\" ) # Call blur with the highest possible radius and sigma req = requests.get( 'https://api.pixlab.io/blur' , params={ 'img' : img, 'key' : key, 'rad' : 50 , 'sig' : 30 } ) reply = req.json() if reply[ 'status' ] != 200 : print(reply[ 'error' ]) else : print( \"Censored image: \" + reply[ 'link' ]) GENERATE INSIGHTS FROM MEDIA SEAMLESSLY With PixLab's Media Analysis APIs, analyze videos and images to extract metadata, detect objects, and gain actionable insights. The Media Analysis API simplifies processing complex data into meaningful information—ideal for developers building intelligent applications. BOOST PRODUCTIVITY WITH INTELLIGENT ANALYTICS Automate your media workflows with PixLab's AI-driven analytics. Use our comprehensive REST APIs documentation to seamlessly integrate advanced media analysis capabilities, enhancing efficiency and delivering powerful results for your projects. UNLOCK MEDIA'S FULL POTENTIAL Tap into PixLab's cutting-edge tools to process media efficiently. Whether it's detecting faces, recognizing objects, or generating metadata, you'll have access to a powerful API suite that turns raw media into actionable insights in no time. Add Custom Text to Your Images in Seconds PixLab's API makes it effortless to overlay text on your images. Whether it's a meme, a marketing banner, or just a creative design, you can draw text on the top and bottom of any image. Customize text size, font, color, and more—all with a single API call. Easily overlay text on images using PixLab's API for creative designs like memes or banners. Customize text size, font, and color with a single API call. Draw text at the top or bottom of any image effortlessly. Convert PDFs into Stunning Images Transform your PDF documents into high-quality JPEG or PNG images effortlessly with PixLab's API. Perfect for archiving, previews, or sharing, our solution makes conversion quick and seamless—no manual effort required. Transform PDF documents into high-quality JPEG or PNG images with PixLab's API. Ideal for archiving, previews, or sharing without manual effort. Ensure quick and seamless document-to-image conversion. Simplify Image Format Conversion Effortlessly convert images between formats such as JPEG, PNG, BMP, and TIFF with PixLab's Format Conversion API. Maintain original dimensions or combine with resizing and cropping endpoints for customized output. Simplify media management across platforms with precise and reliable format transformations. Convert images between formats like JPEG, PNG, BMP, and TIFF using PixLab's Format Conversion API. Preserve original dimensions or apply resizing and cropping for tailored output. Simplify media management with precise and reliable format transformations. Intelligent NSFW Detection & Automated Blurring Ensure safe content with PixLab's NSFW Detection API. This endpoint analyzes images or video frames to detect inappropriate content, such as nudity or adult visuals. Based on the NSFW score, the API can automatically apply a blur filter, increasing intensity for higher scores. Automate content moderation and filtering to create a secure and user-friendly platform effortlessly. Use PixLab's NSFW Detection API to analyze images or video frames for inappropriate content like nudity or adult visuals. Automatically apply a blur filter with adjustable intensity based on the NSFW score. Streamline content moderation and filtering to ensure a secure and user-friendly platform. Endless Possibilities with PixLab From automating workflows to enhancing user experiences, PixLab APIs power solutions across industries. Discover how our tools can transform your projects and unlock new opportunities. E-commerce Optimization Enhance product images and automate content moderation for online stores. Entertainment & Media Generate metadata, analyze videos, and optimize media libraries effortlessly. Identity Verification Securely verify IDs and process documents with advanced OCR capabilities. Healthcare Solutions Analyze medical images for diagnostics and streamline healthcare workflows. Social Media Platforms Moderate content, detect objects, and enhance user-generated media with AI tools. Business Automation Simplify document processing, data extraction, and media handling for enterprises. Get your API Key Endless Possibilities with PixLab From automating workflows to enhancing user experiences, PixLab APIs power solutions across industries. Discover how our tools can transform your projects and unlock new opportunities. Enhance product images and automate content moderation for online stores. Generate metadata, analyze videos, and optimize media libraries effortlessly. Securely verify IDs and process documents with advanced OCR capabilities. Analyze medical images for diagnostics and streamline healthcare workflows. Moderate content, detect objects, and enhance user-generated media with AI tools. Simplify document processing, data extraction, and media handling for enterprises. Built for scale, trusted by thousands Built for scale, trusted by thousands Explore Endless Possibilities with PixLab's APIs API PORTAL CODE SAMPLES INTEGRATION API ENDPOINTS Explore Endless Possibilities with PixLab's APIs",
    "Get Started Now Drag-and-Drop Interface Create and connect nodes in seconds Real-Time Collaboration Work with your team instantly from anywhere Custom Templates Start fast with layouts for planning, education, and more Export Options Download your map as PNG, SVG, or PDF Dark Mode Ready Designed for your workspace comfort Cloud Autosave Your mind maps are saved automatically, so you never lose progress Launch Pixlab Online Mind Map Maker One Tool, Endless Use Cases Built for Teams, Educators, and Creators Whether you're an agile coach, educator, startup founder, or student — PixLab Mind Map adapts to how you think. Product Planning & Sprint Mapping Lesson Planning & Classroom Visuals Startup Brainstorming & Pitch Maps Creative Writing & Storyboarding Get Started Today Your Data, Always Protected Security & Reliability You Can Trust We take privacy seriously. Files are encrypted during storage and automatically removed after 24 hours — no questions asked. Encrypted File Handling GDPR Compliant Infrastructure No Persistent Storage Unless You Want It Launch Online Mind Map Maker Design Your Mind Map, Your Way Flexible Tools for Effortless Creativity Take full control of your mind maps with a variety of customization tools. Whether you're mapping ideas for work, school, or personal projects, PixLab Mind Map Maker gives you the freedom to design your thoughts visually. Start with ready-made layouts for brainstorming, planning, and more. Add quick thoughts or reminders to keep track of ideas. Personalize your mind map with custom colors and backgrounds. Craft Your Idean Now One Platform. Endless Possibilities Fully Integrated with PixLab's Creative Tools PixLab Mind Map seamlessly connects with PixLab AI Photo Editor and Vision Workspace, giving you access to a powerful creative suite. Edit images, annotate diagrams, and enhance visuals—all within a single ecosystem. AI-Powered Image Editing Vision-Based Data Insights Smart Annotations & Export Options Launch Online Mind Map Maker How to Get Started? 1 Open PixLab Mind Map Maker No signup required! Just launch the app and start mapping instantly. 2 Add Your First Node Click anywhere on the canvas to create your first idea node. 3 Connect And Organize Drag and link nodes effortlessly to structure your thoughts. 4 Customize Your Mind Map Adjust colors, layouts, and themes to match your workflow. 5 Export And Share Download your mind map as a PNG file for easy sharing and presentations. Launch Mind Map Maker User-Friendly Interface Allows for easy creation and management of mind maps without a steep learning curve. Collaboration Tools Enables multiple users to work together in real-time, enhancing teamwork and idea development. Template Library Offers a selection of templates to jumpstart the mind-mapping process, catering to various use cases. Integration Seamlessly integrates with other PixLab services, such as AI Photo Editor and Vision Workspace, providing a comprehensive suite for creative tasks. No, you can start creating mind maps instantly without signing up! Just open the app and begin mapping your ideas. You can change colors, backgrounds, and node shapes (rectangles, ellipses, sticky notes) to personalize your mind maps. Yes! PixLab Mind Map Maker offers ready-made templates to help you get started quickly, whether you're brainstorming, planning, or studying. PixLab Vision prioritizes data security and privacy. Currently, you can export your mind maps as PNG files for easy sharing and presentations. Yes, you can use the tool for free with all core features. Join Thousands of Visual Thinkers, Get Started Today. Whether you're sketching your next big idea or streamlining team communication, PixLab Mind Map is the fastest way to bring ideas to life. Start Creating for Free Drag-and-Drop Interface Create and connect nodes in seconds Real-Time Collaboration Work with your team instantly from anywhere Custom Templates Start fast with layouts for planning, education, and more Export Options Download your map as PNG, SVG, or PDF Dark Mode Ready Designed for your workspace comfort Cloud Autosave Your mind maps are saved automatically, so you never lose progress Launch Pixlab Online Mind Map Maker One Tool, Endless Use Cases Built for Teams, Educators, and Creators Whether you're an agile coach, educator, startup founder, or student — PixLab Mind Map adapts to how you think. Product Planning & Sprint Mapping Lesson Planning & Classroom Visuals Startup Brainstorming & Pitch Maps Creative Writing & Storyboarding Get Started Today Your Data, Always Protected Security & Reliability You Can Trust We take privacy seriously. Files are encrypted during storage and automatically removed after 24 hours — no questions asked. Encrypted File Handling GDPR Compliant Infrastructure No Persistent Storage Unless You Want It Launch Online Mind Map Maker Design Your Mind Map, Your Way Flexible Tools for Effortless Creativity Take full control of your mind maps with a variety of customization tools. Whether you're mapping ideas for work, school, or personal projects, PixLab Mind Map Maker gives you the freedom to design your thoughts visually. Start with ready-made layouts for brainstorming, planning, and more. Add quick thoughts or reminders to keep track of ideas. Personalize your mind map with custom colors and backgrounds. Craft Your Idean Now One Platform. Endless Possibilities Fully Integrated with PixLab's Creative Tools PixLab Mind Map seamlessly connects with PixLab AI Photo Editor and Vision Workspace, giving you access to a powerful creative suite. Edit images, annotate diagrams, and enhance visuals—all within a single ecosystem. AI-Powered Image Editing Vision-Based Data Insights Smart Annotations & Export Options Launch Online Mind Map Maker Create and connect nodes in seconds Work with your team instantly from anywhere Start fast with layouts for planning, education, and more Download your map as PNG, SVG, or PDF Designed for your workspace comfort Your mind maps are saved automatically, so you never lose progress One Tool, Endless Use Cases Built for Teams, Educators, and Creators Whether you're an agile coach, educator, startup founder, or student — PixLab Mind Map adapts to how you think. Product Planning & Sprint Mapping Lesson Planning & Classroom Visuals Startup Brainstorming & Pitch Maps Creative Writing & Storyboarding Your Data, Always Protected Security & Reliability You Can Trust We take privacy seriously. Files are encrypted during storage and automatically removed after 24 hours — no questions asked. No Persistent Storage Unless You Want It Design Your Mind Map, Your Way Flexible Tools for Effortless Creativity Take full control of your mind maps with a variety of customization tools. Whether you're mapping ideas for work, school, or personal projects, PixLab Mind Map Maker gives you the freedom to design your thoughts visually. Start with ready-made layouts for brainstorming, planning, and more. Add quick thoughts or reminders to keep track of ideas. Personalize your mind map with custom colors and backgrounds. One Platform. Endless Possibilities Fully Integrated with PixLab's Creative Tools PixLab Mind Map seamlessly connects with PixLab AI Photo Editor and Vision Workspace, giving you access to a powerful creative suite. Edit images, annotate diagrams, and enhance visuals—all within a single ecosystem. Smart Annotations & Export Options How to Get Started? 1 Open PixLab Mind Map Maker No signup required! Just launch the app and start mapping instantly. 2 Add Your First Node Click anywhere on the canvas to create your first idea node. 3 Connect And Organize Drag and link nodes effortlessly to structure your thoughts. 4 Customize Your Mind Map Adjust colors, layouts, and themes to match your workflow. 5 Export And Share Download your mind map as a PNG file for easy sharing and presentations. Launch Mind Map Maker How to Get Started? Open PixLab Mind Map Maker No signup required! Just launch the app and start mapping instantly. Add Your First Node Click anywhere on the canvas to create your first idea node. Drag and link nodes effortlessly to structure your thoughts. Customize Your Mind Map Adjust colors, layouts, and themes to match your workflow. Download your mind map as a PNG file for easy sharing and presentations. User-Friendly Interface Allows for easy creation and management of mind maps without a steep learning curve. Collaboration Tools Enables multiple users to work together in real-time, enhancing teamwork and idea development. Template Library Offers a selection of templates to jumpstart the mind-mapping process, catering to various use cases. Integration Seamlessly integrates with other PixLab services, such as AI Photo Editor and Vision Workspace, providing a comprehensive suite for creative tasks. Allows for easy creation and management of mind maps without a steep learning curve. Enables multiple users to work together in real-time, enhancing teamwork and idea development. Offers a selection of templates to jumpstart the mind-mapping process, catering to various use cases. Seamlessly integrates with other PixLab services, such as AI Photo Editor and Vision Workspace, providing a comprehensive suite for creative tasks. No, you can start creating mind maps instantly without signing up! Just open the app and begin mapping your ideas. You can change colors, backgrounds, and node shapes (rectangles, ellipses, sticky notes) to personalize your mind maps. Yes! PixLab Mind Map Maker offers ready-made templates to help you get started quickly, whether you're brainstorming, planning, or studying. PixLab Vision prioritizes data security and privacy. Currently, you can export your mind maps as PNG files for easy sharing and presentations. Yes, you can use the tool for free with all core features. No, you can start creating mind maps instantly without signing up! Just open the app and begin mapping your ideas. You can change colors, backgrounds, and node shapes (rectangles, ellipses, sticky notes) to personalize your mind maps. Yes! PixLab Mind Map Maker offers ready-made templates to help you get started quickly, whether you're brainstorming, planning, or studying. PixLab Vision prioritizes data security and privacy. Currently, you can export your mind maps as PNG files for easy sharing and presentations. Yes, you can use the tool for free with all core features. Join Thousands of Visual Thinkers, Get Started Today. Whether you're sketching your next big idea or streamlining team communication, PixLab Mind Map is the fastest way to bring ideas to life. Start Creating for Free Join Thousands of Visual Thinkers, Get Started Today. Whether you're sketching your next big idea or streamlining team communication, PixLab Mind Map is the fastest way to bring ideas to life."
  ]
}